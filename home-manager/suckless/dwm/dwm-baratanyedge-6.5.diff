diff -up -x Makefile dwmorig/config.def.h dwmnew/config.def.h
--- dwmorig/config.def.h	2024-03-27 22:37:23.676297919 +0200
+++ dwmnew/config.def.h	2024-03-27 22:37:23.684297919 +0200
@@ -4,7 +4,8 @@
 static const unsigned int borderpx  = 1;        /* border pixel of windows */
 static const unsigned int snap      = 32;       /* snap pixel */
 static const int showbar            = 1;        /* 0 means no bar */
-static const int topbar             = 1;        /* 0 means bottom bar */
+static const int baredge            = 2;        /* 0 = bottom, 1 = top, 2 = left, 3 = right */
+static const int barord             = 1;        /* 0: original; 1: inverted */
 static const char *fonts[]          = { "monospace:size=10" };
 static const char dmenufont[]       = "monospace:size=10";
 static const char col_gray1[]       = "#222222";
diff -up -x Makefile dwmorig/dwm.c dwmnew/dwm.c
--- dwmorig/dwm.c	2024-03-27 22:37:23.676297919 +0200
+++ dwmnew/dwm.c	2024-03-27 22:37:23.688297919 +0200
@@ -116,14 +116,13 @@ struct Monitor {
 	float mfact;
 	int nmaster;
 	int num;
-	int by;               /* bar geometry */
+	int bx, by, bw, bh;   /* bar geometry */
 	int mx, my, mw, mh;   /* screen size */
 	int wx, wy, ww, wh;   /* window area  */
 	unsigned int seltags;
 	unsigned int sellt;
 	unsigned int tagset[2];
 	int showbar;
-	int topbar;
 	Client *clients;
 	Client *sel;
 	Client *stack;
@@ -193,6 +192,7 @@ static void resize(Client *c, int x, int
 static void resizeclient(Client *c, int x, int y, int w, int h);
 static void resizemouse(const Arg *arg);
 static void restack(Monitor *m);
+static void rotateimage(XImage *img);
 static void run(void);
 static void scan(void);
 static int sendevent(Client *c, Atom proto);
@@ -239,7 +239,7 @@ static const char broken[] = "broken";
 static char stext[256];
 static int screen;
 static int sw, sh;           /* X display screen geometry width, height */
-static int bh;               /* bar height */
+static int bt;               /* if baredge <= 1: bar height; else bar width */
 static int lrpad;            /* sum of left and right padding for text */
 static int (*xerrorxlib)(Display *, XErrorEvent *);
 static unsigned int numlockmask = 0;
@@ -339,10 +339,10 @@ applysizehints(Client *c, int *x, int *y
 		if (*y + *h + 2 * c->bw <= m->wy)
 			*y = m->wy;
 	}
-	if (*h < bh)
-		*h = bh;
-	if (*w < bh)
-		*w = bh;
+	if (*h < bt)
+		*h = bt;
+	if (*w < bt)
+		*w = bt;
 	if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
 		if (!c->hintsvalid)
 			updatesizehints(c);
@@ -418,7 +418,7 @@ attachstack(Client *c)
 void
 buttonpress(XEvent *e)
 {
-	unsigned int i, x, click;
+	unsigned int i, x, evx, click;
 	Arg arg = {0};
 	Client *c;
 	Monitor *m;
@@ -433,15 +433,22 @@ buttonpress(XEvent *e)
 	}
 	if (ev->window == selmon->barwin) {
 		i = x = 0;
+		/* Set evx according baredge and barord */
+		if (baredge <= 1)
+			evx = barord ? selmon->ww - ev->x : ev->x;
+		else if (baredge == 2)
+			evx = barord ? ev->y : selmon->wh - ev->y;
+		else  /* baredge == 3 */
+			evx = barord ? selmon->wh - ev->y : ev->y;
 		do
 			x += TEXTW(tags[i]);
-		while (ev->x >= x && ++i < LENGTH(tags));
+		while (evx >= x && ++i < LENGTH(tags));
 		if (i < LENGTH(tags)) {
 			click = ClkTagBar;
 			arg.ui = 1 << i;
-		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
+		} else if (evx < x + TEXTW(selmon->ltsymbol))
 			click = ClkLtSymbol;
-		else if (ev->x > selmon->ww - (int)TEXTW(stext))
+		else if (evx > selmon->ww - (int)TEXTW(stext))
 			click = ClkStatusText;
 		else
 			click = ClkWinTitle;
@@ -564,13 +571,16 @@ configurenotify(XEvent *e)
 		sw = ev->width;
 		sh = ev->height;
 		if (updategeom() || dirty) {
-			drw_resize(drw, sw, bh);
+			if (baredge <= 1)  /* bottom or top bar */
+				drw_resize(drw, sw, bt);
+			else  /* left or right bar */
+				drw_resize(drw, sh, bt);
 			updatebars();
 			for (m = mons; m; m = m->next) {
 				for (c = m->clients; c; c = c->next)
 					if (c->isfullscreen)
 						resizeclient(c, m->mx, m->my, m->mw, m->mh);
-				XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
+				XMoveResizeWindow(dpy, m->barwin, m->bx, m->by, m->bw, m->bh);
 			}
 			focus(NULL);
 			arrange(NULL);
@@ -640,7 +650,6 @@ createmon(void)
 	m->mfact = mfact;
 	m->nmaster = nmaster;
 	m->showbar = showbar;
-	m->topbar = topbar;
 	m->lt[0] = &layouts[0];
 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
@@ -696,13 +705,46 @@ dirtomon(int dir)
 }
 
 void
+rotateimage(XImage *img)
+{
+	int mi, mj;
+	int i, j; 
+	int wminus1 = img->width - 1;
+	int wminus2 = img->width - 2;
+	unsigned long p;  /* temporarily stored pixel */
+	for (j = wminus2 >> 1; j >= 0; j--) {
+		mj = wminus1 - j;
+		for (i = wminus2 - j; i >= j; i--) {
+			mi = wminus1 - i;
+			p = XGetPixel(img, j, i);
+			if (baredge == 2) { /* 90 deg rotation */ 
+				XPutPixel(img, j, i, XGetPixel(img, mi, j));
+				XPutPixel(img, mi, j, XGetPixel(img, mj, mi));
+				XPutPixel(img, mj, mi, XGetPixel(img, i, mj));
+				XPutPixel(img, i, mj, p);
+			} else {  /* -90 deg rotation */
+				XPutPixel(img, j, i, XGetPixel(img, i, mj));
+				XPutPixel(img, i, mj, XGetPixel(img, mj, mi));
+				XPutPixel(img, mj, mi, XGetPixel(img, mi, j));
+				XPutPixel(img, mi, j, p);
+			}
+		}
+	}
+}
+
+void
 drawbar(Monitor *m)
 {
+	/* Draw bar always first to the horizontal pixmap (drw), and then
+	 * rotate if needed and move it to the bar window */
 	int x, w, tw = 0;
 	int boxs = drw->fonts->h / 9;
 	int boxw = drw->fonts->h / 6 + 2;
 	unsigned int i, occ = 0, urg = 0;
 	Client *c;
+	int drwwidth = (baredge <= 1) ? m->bw : m->bh;
+	int pad;
+	XImage *img;
 
 	if (!m->showbar)
 		return;
@@ -710,8 +752,8 @@ drawbar(Monitor *m)
 	/* draw status first so it can be overdrawn by tags later */
 	if (m == selmon) { /* status is only drawn on selected monitor */
 		drw_setscheme(drw, scheme[SchemeNorm]);
-		tw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
-		drw_text(drw, m->ww - tw, 0, tw, bh, 0, stext, 0);
+		tw = TEXTW(stext) - lrpad + 4; /* 2+2px left+right padding */
+		drw_text(drw, (barord ? 0 : drwwidth - tw), 0, tw, bt, 2, stext, 0);
 	}
 
 	for (c = m->clients; c; c = c->next) {
@@ -723,29 +765,54 @@ drawbar(Monitor *m)
 	for (i = 0; i < LENGTH(tags); i++) {
 		w = TEXTW(tags[i]);
 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
-		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
+		drw_text(drw, (barord ? drwwidth - x - w : x), 0, w, bt, lrpad / 2, tags[i], urg & 1 << i);
 		if (occ & 1 << i)
-			drw_rect(drw, x + boxs, boxs, boxw, boxw,
+			drw_rect(drw, (barord ? drwwidth - x - w : x) + boxs, boxs, boxw, boxw,
 				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
 				urg & 1 << i);
 		x += w;
 	}
 	w = TEXTW(m->ltsymbol);
 	drw_setscheme(drw, scheme[SchemeNorm]);
-	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
+	drw_text(drw, (barord ? drwwidth - x - w : x), 0, w, bt, lrpad / 2, m->ltsymbol, 0);
+	x += w;
 
-	if ((w = m->ww - tw - x) > bh) {
+	if ((w = drwwidth - tw - x) > bt) {
+		if (barord)
+		       x = tw;
 		if (m->sel) {
 			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
-			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
+			if ((!barord) || ((pad = w - TEXTW(m->sel->name)) < 0))
+				pad = 0;
+			drw_text(drw, x, 0, w, bt, pad + (lrpad / 2), m->sel->name, 0);
 			if (m->sel->isfloating)
-				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
+				drw_rect(drw, x + pad + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
 		} else {
 			drw_setscheme(drw, scheme[SchemeNorm]);
-			drw_rect(drw, x, 0, w, bh, 1, 1);
+			drw_rect(drw, x, 0, w, bt, 1, 1);
+		}
+	}
+
+	if (baredge <= 1) {  /* Horizontal bar - no rotation */
+		drw_map(drw, m->barwin, 0, 0, m->ww, bt);
+	} else  { /* rotate image */ 
+		img = XGetImage(dpy, drw->drawable, m->bh - bt, 0, bt, bt, AllPlanes, ZPixmap);
+		rotateimage(img);
+		if (baredge == 2) /* 90 deg rotation */ 
+			XPutImage(dpy, m->barwin, drw->gc, img, 0, 0, 0, 0, bt, bt);
+		else  /* baredge == 3, -90 deg rotation */ 
+			XPutImage(dpy, m->barwin, drw->gc, img, 0, 0, 0, m->bh - bt, bt, bt);
+		for (x = 0; x < (m->bh - bt); x = x + bt) {
+			img = XGetSubImage(dpy, drw->drawable, x, 0, bt, bt, AllPlanes, ZPixmap, img, 0, 0);
+			rotateimage(img);
+			if (baredge == 2) /* 90 deg rotation */ 
+				XPutImage(dpy, m->barwin, drw->gc, img, 0, 0, 0, m->bh - bt - x, bt, bt);
+			else  /* baredge == 3, -90 deg rotation */ 
+				XPutImage(dpy, m->barwin, drw->gc, img, 0, 0, 0, x, bt, bt);
 		}
+		XDestroyImage(img);
+		XSync(dpy, False);
 	}
-	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
 }
 
 void
@@ -1562,7 +1629,7 @@ setup(void)
 	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
 		die("no fonts could be loaded.");
 	lrpad = drw->fonts->h;
-	bh = drw->fonts->h + 2;
+	bt = drw->fonts->h + 2;
 	updategeom();
 	/* init atoms */
 	utf8string = XInternAtom(dpy, "UTF8_STRING", False);
@@ -1717,7 +1784,7 @@ togglebar(const Arg *arg)
 {
 	selmon->showbar = !selmon->showbar;
 	updatebarpos(selmon);
-	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
+	XMoveResizeWindow(dpy, selmon->barwin, selmon->bx, selmon->by, selmon->bw, selmon->bh);
 	arrange(selmon);
 }
 
@@ -1828,7 +1895,7 @@ updatebars(void)
 	for (m = mons; m; m = m->next) {
 		if (m->barwin)
 			continue;
-		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
+		m->barwin = XCreateWindow(dpy, root, m->bx, m->by, m->bw, m->bh, 0, DefaultDepth(dpy, screen),
 				CopyFromParent, DefaultVisual(dpy, screen),
 				CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
 		XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
@@ -1840,14 +1907,32 @@ updatebars(void)
 void
 updatebarpos(Monitor *m)
 {
+	m->wx = m->mx;
 	m->wy = m->my;
+	m->ww = m->mw;
 	m->wh = m->mh;
 	if (m->showbar) {
-		m->wh -= bh;
-		m->by = m->topbar ? m->wy : m->wy + m->wh;
-		m->wy = m->topbar ? m->wy + bh : m->wy;
+		if (baredge <= 1) {  /* bottom or top bar */
+			m->wh -= bt;
+			m->by = (baredge) ? m->wy : m->wy + m->wh;
+			m->wy = (baredge) ? m->wy + bt : m->wy;
+			m->bx = m->wx;
+			m->bw = m->ww;
+			m->bh = bt;
+		} else {  /* left or right bar */
+			m->ww -= bt;
+			m->bx = (baredge == 2) ? m->wx : m->wx + m->ww;
+			m->wx = (baredge == 2) ? m->wx + bt : m->wx;
+			m->by = m->wy;
+			m->bw = bt;
+			m->bh = m->wh;
+		} 
 	} else
-		m->by = -bh;
+		if (baredge <= 1) {
+			m->by = -bt;
+		} else {
+			m->bx = -bt;
+		} 
 }
 
 void
@@ -1901,10 +1986,10 @@ updategeom(void)
 			{
 				dirty = 1;
 				m->num = i;
-				m->mx = m->wx = unique[i].x_org;
-				m->my = m->wy = unique[i].y_org;
-				m->mw = m->ww = unique[i].width;
-				m->mh = m->wh = unique[i].height;
+				m->mx = unique[i].x_org;
+				m->my = unique[i].y_org;
+				m->mw = unique[i].width;
+				m->mh = unique[i].height;
 				updatebarpos(m);
 			}
 		/* removed monitors if n > nn */
@@ -1930,8 +2015,8 @@ updategeom(void)
 			mons = createmon();
 		if (mons->mw != sw || mons->mh != sh) {
 			dirty = 1;
-			mons->mw = mons->ww = sw;
-			mons->mh = mons->wh = sh;
+			mons->mw = sw;
+			mons->mh = sh;
 			updatebarpos(mons);
 		}
 	}
